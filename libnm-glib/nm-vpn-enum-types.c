


/* Generated by glib-mkenums. Do not edit */

#include "nm-vpn-enum-types.h"

#include "nm-vpn-plugin.h" 
#include "nm-vpn-plugin-ui-interface.h" 
#include "nm-vpn-plugin-utils.h"

GType
nm_vpn_plugin_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_VPN_PLUGIN_ERROR_GENERAL, "NM_VPN_PLUGIN_ERROR_GENERAL", "General" },
        { NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS, "NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS", "StartingInProgress" },
        { NM_VPN_PLUGIN_ERROR_ALREADY_STARTED, "NM_VPN_PLUGIN_ERROR_ALREADY_STARTED", "AlreadyStarted" },
        { NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS, "NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS", "StoppingInProgress" },
        { NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED, "NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED", "AlreadyStopped" },
        { NM_VPN_PLUGIN_ERROR_WRONG_STATE, "NM_VPN_PLUGIN_ERROR_WRONG_STATE", "WrongState" },
        { NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS, "NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS", "BadArguments" },
        { NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED, "NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED", "LaunchFailed" },
        { NM_VPN_PLUGIN_ERROR_CONNECTION_INVALID, "NM_VPN_PLUGIN_ERROR_CONNECTION_INVALID", "ConnectionInvalid" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMVPNPluginError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vpn_plugin_ui_capability_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_VPN_PLUGIN_UI_CAPABILITY_NONE, "NM_VPN_PLUGIN_UI_CAPABILITY_NONE", "none" },
        { NM_VPN_PLUGIN_UI_CAPABILITY_IMPORT, "NM_VPN_PLUGIN_UI_CAPABILITY_IMPORT", "import" },
        { NM_VPN_PLUGIN_UI_CAPABILITY_EXPORT, "NM_VPN_PLUGIN_UI_CAPABILITY_EXPORT", "export" },
        { NM_VPN_PLUGIN_UI_CAPABILITY_IPV6, "NM_VPN_PLUGIN_UI_CAPABILITY_IPV6", "ipv6" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMVpnPluginUiCapability"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_vpn_plugin_ui_interface_prop_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_VPN_PLUGIN_UI_INTERFACE_PROP_FIRST, "NM_VPN_PLUGIN_UI_INTERFACE_PROP_FIRST", "first" },
        { NM_VPN_PLUGIN_UI_INTERFACE_PROP_NAME, "NM_VPN_PLUGIN_UI_INTERFACE_PROP_NAME", "name" },
        { NM_VPN_PLUGIN_UI_INTERFACE_PROP_DESC, "NM_VPN_PLUGIN_UI_INTERFACE_PROP_DESC", "desc" },
        { NM_VPN_PLUGIN_UI_INTERFACE_PROP_SERVICE, "NM_VPN_PLUGIN_UI_INTERFACE_PROP_SERVICE", "service" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMVpnPluginUiInterfaceProp"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}



